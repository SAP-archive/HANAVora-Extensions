package org.apache.spark.sql.catalyst.plans.logical

import org.apache.spark.sql.catalyst.analysis.Resolver
import org.apache.spark.sql.catalyst.expressions._
import org.apache.spark.sql.types.{DataType, NodeType}

case class Hierarchy(
                      relation: LogicalPlan,
                      childAlias: String,
                      parenthoodExpression: Expression,
                      searchBy: Seq[SortOrder],
                      startWhere: Option[Expression],
                      nodeAttribute: Attribute)
  extends UnaryNode {

  override def child: LogicalPlan = relation

  override def output: Seq[Attribute] = child.output :+ nodeAttribute

  /* TODO: This will be needed if we use generic Node inner types */
  private val joinDataType: Option[DataType] = {
    parenthoodExpression match {
      case be: BinaryExpression if be.resolved && be.left.dataType.sameType(be.right.dataType) =>
        Some(be.left.dataType)
      case x if !parenthoodExpression.resolved =>
        None
      case _ =>
        throw new IllegalArgumentException(
          "Hierarchy only supports binary expressions on JOIN PARENT"
        )
    }
  }

  override lazy val resolved: Boolean = !expressions.exists(!_.resolved) &&
    childrenResolved &&
    parenthoodExpression.resolved &&
    (startWhere.isEmpty || startWhere.get.resolved)
    searchBy.map(_.resolved).forall(_ == true) &&
    nodeAttribute.resolved

  /**
   * When checking missing input attributes, ignore the node attribute
   * (which is generated by this plan) and any attribute in the parenthood
   * expression.
   *
   * XXX: Ignoring the parenthood expression is a hack to avoid more complex
   *      handling of expression IDs for the child relation and its "parent alias".
   */
  override def missingInput: AttributeSet =
    references -- inputSet -- referencesInParenthoodExpressionSet - nodeAttribute

  private def referencesInParenthoodExpressionSet: AttributeSet =
    AttributeSet(parenthoodExpression.collect({ case a: Attribute => a }))

  private def candidateAttributesForParenthoodExpression(): Seq[Attribute] =
    relation.output ++ relation.output.map({
      case attr => Alias(attr, attr.name)(qualifiers = childAlias :: Nil).toAttribute
    })

  private[sql] def resolveParenthoodExpression(nameParts: Seq[String], resolver: Resolver)
    : Option[NamedExpression] =
    resolve(nameParts, candidateAttributesForParenthoodExpression(), resolver, true)

  private[sql] def resolveNodeAttribute(): Option[Attribute] =
    relation.resolved && parenthoodExpression.resolved match {
      case _ if nodeAttribute.resolved => Some(nodeAttribute)
      case false => None
      case true if joinDataType.isDefined =>
        Some(AttributeReference(nodeAttribute.name, NodeType, nullable = false)())
      case _ => None
    }

}
